# 설계 원칙의 목적
- 변경에 유연
- 이해하기 쉬움
- 컴포넌트로 구성될 수 있음

# SOLID원칙

- 고수준의 원칙
- 저수준에 대한 결정을 지연하기 위한 원칙

## SRP(Single Responsibility Principle)
> 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

매서드와 클래스 수준의 원칙으로, '응집성'에 대한 원칙이다. 여기서 '액터'란 변경을 가져오는 원인을 의미하며, '모듈'이란 어떤 문제를 해결하기 위한 기능 집합을 말한다.

### 생각
변경 자체가 아닌, 변경의 원인으로 분리 혹은 결합을 할 수 있도록 정리하는 습관을 가지면 좋을 것 같다.
## OCP(Open-Close Principle)
> 개체(artifect)는 확장에 열려있고, 변경에 닫혀야 한다.

기능이 언제, 왜, 어떻게 생성되는지에 따라 기능을 분리하고, 컴포넌트로 계층을 구조화 한다.

### 생각
TDD에서 일단 되게 하고, 분할하면서 만들어 가는 방식이 떠올랐다. 지금의 나는 일단 중복이 발생하면 따로 빼서 만들어 두곤 했는데, 좀 더 신중하게 처리해야 겠다.

## LSP(Liskov Substitution Principle)
> sub type과 원 타입은 치환 가능해야 한다.

추상화를 한 개체의 이용은 하위 타입에 대해서 항상 가능해야 한다.

### 생각
재귀적인 컴포넌트를 가지고 만들때, 사용해 보면 좋겠다는 생각이 들었다.

## ISP(Interface Segregation Principle)
> 의존은 필요한 부분에 대해서만 진행한다.

불필요한 의존관계에 따른 불필요한 재컴파일, 재배포, 수정은 바람직하지 못하다.

### + 의존은 언어와 관련된 문제?
정적 타입 언어에서는 import, use, include와 같은 타입 선언문을 통해 모듈을 참조한다. 이러한 방법 때문에 변경에 대한 재배포가 무조건 적으로 이루어져야 한다. 동적 타입 언어에서는 '타입의 선언'이 아니라, '런타임 추론'이 이루어 진다. 이에 따라 결합도가 좀 더 낮은 시스템을 만들 수 있다.

### 생각
Javscript에서 모듈을 로드하는 방식을 생각해 보면, 쉬운 것 같다.

## DIP(Dependency Inversion Principle)
> 변동성이 큰 요소에 대한 의존성 방향을 바꿔라.

안정된 추상화 등을 통해 변동성이 큰 구현체가 아닌, 특정 정의에 시스템을 의존시켜라.

### 생각
render함수가 이런 방식인 것 같다.